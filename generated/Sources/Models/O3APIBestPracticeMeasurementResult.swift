//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class O3APIBestPracticeMeasurementResult: APIModel {

    public enum O3APILongTermTrendType: Int, Codable, Equatable, CaseIterable {
        case _0 = 0
        case _1 = 1
        case _2 = 2
        case undecodable

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(Int.self)
            self = O3APILongTermTrendType(rawValue: rawValue) ?? .undecodable
        }
    }

    public enum O3APIShortTermTrendType: Int, Codable, Equatable, CaseIterable {
        case _0 = 0
        case _1 = 1
        case _2 = 2
        case undecodable

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(Int.self)
            self = O3APIShortTermTrendType(rawValue: rawValue) ?? .undecodable
        }
    }

    public var actualValue: Double?

    public var bestPracticeMeasurementID: Int?

    public var calculationEndTime: DateTime?

    public var calculationStartTime: DateTime?

    public var createdByUserID: Int?

    public var dateCreated: DateTime?

    public var dateDeleted: DateTime?

    public var dateModified: DateTime?

    public var deletedByUserID: Int?

    public var id: Int?

    public var isDeleted: Bool?

    public var longTermTrendResult: Double?

    public var longTermTrendType: O3APILongTermTrendType?

    public var modifiedByUserID: Int?

    public var scoreValue: Double?

    public var shortTermTrendResult: Double?

    public var shortTermTrendType: O3APIShortTermTrendType?

    public init(actualValue: Double? = nil, bestPracticeMeasurementID: Int? = nil, calculationEndTime: DateTime? = nil, calculationStartTime: DateTime? = nil, createdByUserID: Int? = nil, dateCreated: DateTime? = nil, dateDeleted: DateTime? = nil, dateModified: DateTime? = nil, deletedByUserID: Int? = nil, id: Int? = nil, isDeleted: Bool? = nil, longTermTrendResult: Double? = nil, longTermTrendType: O3APILongTermTrendType? = nil, modifiedByUserID: Int? = nil, scoreValue: Double? = nil, shortTermTrendResult: Double? = nil, shortTermTrendType: O3APIShortTermTrendType? = nil) {
        self.actualValue = actualValue
        self.bestPracticeMeasurementID = bestPracticeMeasurementID
        self.calculationEndTime = calculationEndTime
        self.calculationStartTime = calculationStartTime
        self.createdByUserID = createdByUserID
        self.dateCreated = dateCreated
        self.dateDeleted = dateDeleted
        self.dateModified = dateModified
        self.deletedByUserID = deletedByUserID
        self.id = id
        self.isDeleted = isDeleted
        self.longTermTrendResult = longTermTrendResult
        self.longTermTrendType = longTermTrendType
        self.modifiedByUserID = modifiedByUserID
        self.scoreValue = scoreValue
        self.shortTermTrendResult = shortTermTrendResult
        self.shortTermTrendType = shortTermTrendType
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        actualValue = try container.decodeIfPresent("ActualValue")
        bestPracticeMeasurementID = try container.decodeIfPresent("BestPracticeMeasurementID")
        calculationEndTime = try container.decodeIfPresent("CalculationEndTime")
        calculationStartTime = try container.decodeIfPresent("CalculationStartTime")
        createdByUserID = try container.decodeIfPresent("CreatedByUserID")
        dateCreated = try container.decodeIfPresent("DateCreated")
        dateDeleted = try container.decodeIfPresent("DateDeleted")
        dateModified = try container.decodeIfPresent("DateModified")
        deletedByUserID = try container.decodeIfPresent("DeletedByUserID")
        id = try container.decodeIfPresent("ID")
        isDeleted = try container.decodeIfPresent("IsDeleted")
        longTermTrendResult = try container.decodeIfPresent("LongTermTrendResult")
        longTermTrendType = try container.decodeIfPresent("LongTermTrendType")
        modifiedByUserID = try container.decodeIfPresent("ModifiedByUserID")
        scoreValue = try container.decodeIfPresent("ScoreValue")
        shortTermTrendResult = try container.decodeIfPresent("ShortTermTrendResult")
        shortTermTrendType = try container.decodeIfPresent("ShortTermTrendType")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(actualValue, forKey: "ActualValue")
        try container.encodeIfPresent(bestPracticeMeasurementID, forKey: "BestPracticeMeasurementID")
        try container.encodeIfPresent(calculationEndTime, forKey: "CalculationEndTime")
        try container.encodeIfPresent(calculationStartTime, forKey: "CalculationStartTime")
        try container.encodeIfPresent(createdByUserID, forKey: "CreatedByUserID")
        try container.encodeIfPresent(dateCreated, forKey: "DateCreated")
        try container.encodeIfPresent(dateDeleted, forKey: "DateDeleted")
        try container.encodeIfPresent(dateModified, forKey: "DateModified")
        try container.encodeIfPresent(deletedByUserID, forKey: "DeletedByUserID")
        try container.encodeIfPresent(id, forKey: "ID")
        try container.encodeIfPresent(isDeleted, forKey: "IsDeleted")
        try container.encodeIfPresent(longTermTrendResult, forKey: "LongTermTrendResult")
        try container.encodeIfPresent(longTermTrendType, forKey: "LongTermTrendType")
        try container.encodeIfPresent(modifiedByUserID, forKey: "ModifiedByUserID")
        try container.encodeIfPresent(scoreValue, forKey: "ScoreValue")
        try container.encodeIfPresent(shortTermTrendResult, forKey: "ShortTermTrendResult")
        try container.encodeIfPresent(shortTermTrendType, forKey: "ShortTermTrendType")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? O3APIBestPracticeMeasurementResult else { return false }
      guard self.actualValue == object.actualValue else { return false }
      guard self.bestPracticeMeasurementID == object.bestPracticeMeasurementID else { return false }
      guard self.calculationEndTime == object.calculationEndTime else { return false }
      guard self.calculationStartTime == object.calculationStartTime else { return false }
      guard self.createdByUserID == object.createdByUserID else { return false }
      guard self.dateCreated == object.dateCreated else { return false }
      guard self.dateDeleted == object.dateDeleted else { return false }
      guard self.dateModified == object.dateModified else { return false }
      guard self.deletedByUserID == object.deletedByUserID else { return false }
      guard self.id == object.id else { return false }
      guard self.isDeleted == object.isDeleted else { return false }
      guard self.longTermTrendResult == object.longTermTrendResult else { return false }
      guard self.longTermTrendType == object.longTermTrendType else { return false }
      guard self.modifiedByUserID == object.modifiedByUserID else { return false }
      guard self.scoreValue == object.scoreValue else { return false }
      guard self.shortTermTrendResult == object.shortTermTrendResult else { return false }
      guard self.shortTermTrendType == object.shortTermTrendType else { return false }
      return true
    }

    public static func == (lhs: O3APIBestPracticeMeasurementResult, rhs: O3APIBestPracticeMeasurementResult) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
