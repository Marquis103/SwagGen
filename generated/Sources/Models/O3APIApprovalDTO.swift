//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class O3APIApprovalDTO: APIModel {

    public var approvedByUser: String?

    public var approvedByUserID: Int?

    public var assignedToRole: String?

    public var assignedToRoleID: Int?

    public var assignedToUser: String?

    public var assignedToUserGroup: String?

    public var assignedToUserGroupID: Int?

    public var assignedToUserID: Int?

    public var canApprove: Bool?

    public var canReject: Bool?

    public var canReopen: Bool?

    public var canSubmit: Bool?

    public var company: String?

    public var companyID: Int?

    public var dateApproved: DateTime?

    public var dateDue: DateTime?

    public var dateRejected: DateTime?

    public var dateSubmitted: DateTime?

    public var description: String?

    public var entityID: Int?

    public var filterText: String?

    public var forecastDate: DateTime?

    public var id: Int?

    public var isEditable: Bool?

    public var isUrgent: Bool?

    public var name: String?

    public var notes: String?

    public var priority: String?

    public var priorityID: Int?

    public var projectID: Int?

    public var rejectedByUser: String?

    public var rejectedByUserID: Int?

    public var rejectionNotes: String?

    public var sortOrder: Int?

    public var status: String?

    public var statusID: Int?

    public var submittedByUser: String?

    public var submittedByUserID: Int?

    public init(approvedByUser: String? = nil, approvedByUserID: Int? = nil, assignedToRole: String? = nil, assignedToRoleID: Int? = nil, assignedToUser: String? = nil, assignedToUserGroup: String? = nil, assignedToUserGroupID: Int? = nil, assignedToUserID: Int? = nil, canApprove: Bool? = nil, canReject: Bool? = nil, canReopen: Bool? = nil, canSubmit: Bool? = nil, company: String? = nil, companyID: Int? = nil, dateApproved: DateTime? = nil, dateDue: DateTime? = nil, dateRejected: DateTime? = nil, dateSubmitted: DateTime? = nil, description: String? = nil, entityID: Int? = nil, filterText: String? = nil, forecastDate: DateTime? = nil, id: Int? = nil, isEditable: Bool? = nil, isUrgent: Bool? = nil, name: String? = nil, notes: String? = nil, priority: String? = nil, priorityID: Int? = nil, projectID: Int? = nil, rejectedByUser: String? = nil, rejectedByUserID: Int? = nil, rejectionNotes: String? = nil, sortOrder: Int? = nil, status: String? = nil, statusID: Int? = nil, submittedByUser: String? = nil, submittedByUserID: Int? = nil) {
        self.approvedByUser = approvedByUser
        self.approvedByUserID = approvedByUserID
        self.assignedToRole = assignedToRole
        self.assignedToRoleID = assignedToRoleID
        self.assignedToUser = assignedToUser
        self.assignedToUserGroup = assignedToUserGroup
        self.assignedToUserGroupID = assignedToUserGroupID
        self.assignedToUserID = assignedToUserID
        self.canApprove = canApprove
        self.canReject = canReject
        self.canReopen = canReopen
        self.canSubmit = canSubmit
        self.company = company
        self.companyID = companyID
        self.dateApproved = dateApproved
        self.dateDue = dateDue
        self.dateRejected = dateRejected
        self.dateSubmitted = dateSubmitted
        self.description = description
        self.entityID = entityID
        self.filterText = filterText
        self.forecastDate = forecastDate
        self.id = id
        self.isEditable = isEditable
        self.isUrgent = isUrgent
        self.name = name
        self.notes = notes
        self.priority = priority
        self.priorityID = priorityID
        self.projectID = projectID
        self.rejectedByUser = rejectedByUser
        self.rejectedByUserID = rejectedByUserID
        self.rejectionNotes = rejectionNotes
        self.sortOrder = sortOrder
        self.status = status
        self.statusID = statusID
        self.submittedByUser = submittedByUser
        self.submittedByUserID = submittedByUserID
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        approvedByUser = try container.decodeIfPresent("ApprovedByUser")
        approvedByUserID = try container.decodeIfPresent("ApprovedByUserID")
        assignedToRole = try container.decodeIfPresent("AssignedToRole")
        assignedToRoleID = try container.decodeIfPresent("AssignedToRoleID")
        assignedToUser = try container.decodeIfPresent("AssignedToUser")
        assignedToUserGroup = try container.decodeIfPresent("AssignedToUserGroup")
        assignedToUserGroupID = try container.decodeIfPresent("AssignedToUserGroupID")
        assignedToUserID = try container.decodeIfPresent("AssignedToUserID")
        canApprove = try container.decodeIfPresent("CanApprove")
        canReject = try container.decodeIfPresent("CanReject")
        canReopen = try container.decodeIfPresent("CanReopen")
        canSubmit = try container.decodeIfPresent("CanSubmit")
        company = try container.decodeIfPresent("Company")
        companyID = try container.decodeIfPresent("CompanyID")
        dateApproved = try container.decodeIfPresent("DateApproved")
        dateDue = try container.decodeIfPresent("DateDue")
        dateRejected = try container.decodeIfPresent("DateRejected")
        dateSubmitted = try container.decodeIfPresent("DateSubmitted")
        description = try container.decodeIfPresent("Description")
        entityID = try container.decodeIfPresent("EntityID")
        filterText = try container.decodeIfPresent("FilterText")
        forecastDate = try container.decodeIfPresent("ForecastDate")
        id = try container.decodeIfPresent("ID")
        isEditable = try container.decodeIfPresent("IsEditable")
        isUrgent = try container.decodeIfPresent("IsUrgent")
        name = try container.decodeIfPresent("Name")
        notes = try container.decodeIfPresent("Notes")
        priority = try container.decodeIfPresent("Priority")
        priorityID = try container.decodeIfPresent("PriorityID")
        projectID = try container.decodeIfPresent("ProjectID")
        rejectedByUser = try container.decodeIfPresent("RejectedByUser")
        rejectedByUserID = try container.decodeIfPresent("RejectedByUserID")
        rejectionNotes = try container.decodeIfPresent("RejectionNotes")
        sortOrder = try container.decodeIfPresent("SortOrder")
        status = try container.decodeIfPresent("Status")
        statusID = try container.decodeIfPresent("StatusID")
        submittedByUser = try container.decodeIfPresent("SubmittedByUser")
        submittedByUserID = try container.decodeIfPresent("SubmittedByUserID")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(approvedByUser, forKey: "ApprovedByUser")
        try container.encodeIfPresent(approvedByUserID, forKey: "ApprovedByUserID")
        try container.encodeIfPresent(assignedToRole, forKey: "AssignedToRole")
        try container.encodeIfPresent(assignedToRoleID, forKey: "AssignedToRoleID")
        try container.encodeIfPresent(assignedToUser, forKey: "AssignedToUser")
        try container.encodeIfPresent(assignedToUserGroup, forKey: "AssignedToUserGroup")
        try container.encodeIfPresent(assignedToUserGroupID, forKey: "AssignedToUserGroupID")
        try container.encodeIfPresent(assignedToUserID, forKey: "AssignedToUserID")
        try container.encodeIfPresent(canApprove, forKey: "CanApprove")
        try container.encodeIfPresent(canReject, forKey: "CanReject")
        try container.encodeIfPresent(canReopen, forKey: "CanReopen")
        try container.encodeIfPresent(canSubmit, forKey: "CanSubmit")
        try container.encodeIfPresent(company, forKey: "Company")
        try container.encodeIfPresent(companyID, forKey: "CompanyID")
        try container.encodeIfPresent(dateApproved, forKey: "DateApproved")
        try container.encodeIfPresent(dateDue, forKey: "DateDue")
        try container.encodeIfPresent(dateRejected, forKey: "DateRejected")
        try container.encodeIfPresent(dateSubmitted, forKey: "DateSubmitted")
        try container.encodeIfPresent(description, forKey: "Description")
        try container.encodeIfPresent(entityID, forKey: "EntityID")
        try container.encodeIfPresent(filterText, forKey: "FilterText")
        try container.encodeIfPresent(forecastDate, forKey: "ForecastDate")
        try container.encodeIfPresent(id, forKey: "ID")
        try container.encodeIfPresent(isEditable, forKey: "IsEditable")
        try container.encodeIfPresent(isUrgent, forKey: "IsUrgent")
        try container.encodeIfPresent(name, forKey: "Name")
        try container.encodeIfPresent(notes, forKey: "Notes")
        try container.encodeIfPresent(priority, forKey: "Priority")
        try container.encodeIfPresent(priorityID, forKey: "PriorityID")
        try container.encodeIfPresent(projectID, forKey: "ProjectID")
        try container.encodeIfPresent(rejectedByUser, forKey: "RejectedByUser")
        try container.encodeIfPresent(rejectedByUserID, forKey: "RejectedByUserID")
        try container.encodeIfPresent(rejectionNotes, forKey: "RejectionNotes")
        try container.encodeIfPresent(sortOrder, forKey: "SortOrder")
        try container.encodeIfPresent(status, forKey: "Status")
        try container.encodeIfPresent(statusID, forKey: "StatusID")
        try container.encodeIfPresent(submittedByUser, forKey: "SubmittedByUser")
        try container.encodeIfPresent(submittedByUserID, forKey: "SubmittedByUserID")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? O3APIApprovalDTO else { return false }
      guard self.approvedByUser == object.approvedByUser else { return false }
      guard self.approvedByUserID == object.approvedByUserID else { return false }
      guard self.assignedToRole == object.assignedToRole else { return false }
      guard self.assignedToRoleID == object.assignedToRoleID else { return false }
      guard self.assignedToUser == object.assignedToUser else { return false }
      guard self.assignedToUserGroup == object.assignedToUserGroup else { return false }
      guard self.assignedToUserGroupID == object.assignedToUserGroupID else { return false }
      guard self.assignedToUserID == object.assignedToUserID else { return false }
      guard self.canApprove == object.canApprove else { return false }
      guard self.canReject == object.canReject else { return false }
      guard self.canReopen == object.canReopen else { return false }
      guard self.canSubmit == object.canSubmit else { return false }
      guard self.company == object.company else { return false }
      guard self.companyID == object.companyID else { return false }
      guard self.dateApproved == object.dateApproved else { return false }
      guard self.dateDue == object.dateDue else { return false }
      guard self.dateRejected == object.dateRejected else { return false }
      guard self.dateSubmitted == object.dateSubmitted else { return false }
      guard self.description == object.description else { return false }
      guard self.entityID == object.entityID else { return false }
      guard self.filterText == object.filterText else { return false }
      guard self.forecastDate == object.forecastDate else { return false }
      guard self.id == object.id else { return false }
      guard self.isEditable == object.isEditable else { return false }
      guard self.isUrgent == object.isUrgent else { return false }
      guard self.name == object.name else { return false }
      guard self.notes == object.notes else { return false }
      guard self.priority == object.priority else { return false }
      guard self.priorityID == object.priorityID else { return false }
      guard self.projectID == object.projectID else { return false }
      guard self.rejectedByUser == object.rejectedByUser else { return false }
      guard self.rejectedByUserID == object.rejectedByUserID else { return false }
      guard self.rejectionNotes == object.rejectionNotes else { return false }
      guard self.sortOrder == object.sortOrder else { return false }
      guard self.status == object.status else { return false }
      guard self.statusID == object.statusID else { return false }
      guard self.submittedByUser == object.submittedByUser else { return false }
      guard self.submittedByUserID == object.submittedByUserID else { return false }
      return true
    }

    public static func == (lhs: O3APIApprovalDTO, rhs: O3APIApprovalDTO) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
