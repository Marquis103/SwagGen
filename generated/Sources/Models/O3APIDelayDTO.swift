//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class O3APIDelayDTO: APIModel {

    public var assignedToRole: String?

    public var assignedToRoleID: Int?

    public var assignedToUser: String?

    public var assignedToUserGroup: String?

    public var assignedToUserGroupID: Int?

    public var assignedToUserID: Int?

    public var canConfirm: Bool?

    public var canInvalidate: Bool?

    public var canReopen: Bool?

    public var canResolve: Bool?

    public var company: String?

    public var companyID: Int?

    public var confirmedByUser: String?

    public var confirmedByUserID: Int?

    public var dateConfirmed: DateTime?

    public var dateDue: DateTime?

    public var dateInvalidated: DateTime?

    public var dateResolved: DateTime?

    public var delayCode: String?

    public var description: String?

    public var entityID: Int?

    public var forecastDate: DateTime?

    public var hoursLost: Int?

    public var id: Int?

    public var invalidatedByUser: String?

    public var invalidatedByUserID: Int?

    public var isEditable: Bool?

    public var isUrgent: Bool?

    public var name: String?

    public var notes: String?

    public var priority: String?

    public var priorityID: Int?

    public var resolutionNotes: String?

    public var resolvedByUser: String?

    public var resolvedByUserID: Int?

    public var sortOrder: Int?

    public var status: String?

    public var statusID: Int?

    public init(assignedToRole: String? = nil, assignedToRoleID: Int? = nil, assignedToUser: String? = nil, assignedToUserGroup: String? = nil, assignedToUserGroupID: Int? = nil, assignedToUserID: Int? = nil, canConfirm: Bool? = nil, canInvalidate: Bool? = nil, canReopen: Bool? = nil, canResolve: Bool? = nil, company: String? = nil, companyID: Int? = nil, confirmedByUser: String? = nil, confirmedByUserID: Int? = nil, dateConfirmed: DateTime? = nil, dateDue: DateTime? = nil, dateInvalidated: DateTime? = nil, dateResolved: DateTime? = nil, delayCode: String? = nil, description: String? = nil, entityID: Int? = nil, forecastDate: DateTime? = nil, hoursLost: Int? = nil, id: Int? = nil, invalidatedByUser: String? = nil, invalidatedByUserID: Int? = nil, isEditable: Bool? = nil, isUrgent: Bool? = nil, name: String? = nil, notes: String? = nil, priority: String? = nil, priorityID: Int? = nil, resolutionNotes: String? = nil, resolvedByUser: String? = nil, resolvedByUserID: Int? = nil, sortOrder: Int? = nil, status: String? = nil, statusID: Int? = nil) {
        self.assignedToRole = assignedToRole
        self.assignedToRoleID = assignedToRoleID
        self.assignedToUser = assignedToUser
        self.assignedToUserGroup = assignedToUserGroup
        self.assignedToUserGroupID = assignedToUserGroupID
        self.assignedToUserID = assignedToUserID
        self.canConfirm = canConfirm
        self.canInvalidate = canInvalidate
        self.canReopen = canReopen
        self.canResolve = canResolve
        self.company = company
        self.companyID = companyID
        self.confirmedByUser = confirmedByUser
        self.confirmedByUserID = confirmedByUserID
        self.dateConfirmed = dateConfirmed
        self.dateDue = dateDue
        self.dateInvalidated = dateInvalidated
        self.dateResolved = dateResolved
        self.delayCode = delayCode
        self.description = description
        self.entityID = entityID
        self.forecastDate = forecastDate
        self.hoursLost = hoursLost
        self.id = id
        self.invalidatedByUser = invalidatedByUser
        self.invalidatedByUserID = invalidatedByUserID
        self.isEditable = isEditable
        self.isUrgent = isUrgent
        self.name = name
        self.notes = notes
        self.priority = priority
        self.priorityID = priorityID
        self.resolutionNotes = resolutionNotes
        self.resolvedByUser = resolvedByUser
        self.resolvedByUserID = resolvedByUserID
        self.sortOrder = sortOrder
        self.status = status
        self.statusID = statusID
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        assignedToRole = try container.decodeIfPresent("AssignedToRole")
        assignedToRoleID = try container.decodeIfPresent("AssignedToRoleID")
        assignedToUser = try container.decodeIfPresent("AssignedToUser")
        assignedToUserGroup = try container.decodeIfPresent("AssignedToUserGroup")
        assignedToUserGroupID = try container.decodeIfPresent("AssignedToUserGroupID")
        assignedToUserID = try container.decodeIfPresent("AssignedToUserID")
        canConfirm = try container.decodeIfPresent("CanConfirm")
        canInvalidate = try container.decodeIfPresent("CanInvalidate")
        canReopen = try container.decodeIfPresent("CanReopen")
        canResolve = try container.decodeIfPresent("CanResolve")
        company = try container.decodeIfPresent("Company")
        companyID = try container.decodeIfPresent("CompanyID")
        confirmedByUser = try container.decodeIfPresent("ConfirmedByUser")
        confirmedByUserID = try container.decodeIfPresent("ConfirmedByUserID")
        dateConfirmed = try container.decodeIfPresent("DateConfirmed")
        dateDue = try container.decodeIfPresent("DateDue")
        dateInvalidated = try container.decodeIfPresent("DateInvalidated")
        dateResolved = try container.decodeIfPresent("DateResolved")
        delayCode = try container.decodeIfPresent("DelayCode")
        description = try container.decodeIfPresent("Description")
        entityID = try container.decodeIfPresent("EntityID")
        forecastDate = try container.decodeIfPresent("ForecastDate")
        hoursLost = try container.decodeIfPresent("HoursLost")
        id = try container.decodeIfPresent("ID")
        invalidatedByUser = try container.decodeIfPresent("InvalidatedByUser")
        invalidatedByUserID = try container.decodeIfPresent("InvalidatedByUserID")
        isEditable = try container.decodeIfPresent("IsEditable")
        isUrgent = try container.decodeIfPresent("IsUrgent")
        name = try container.decodeIfPresent("Name")
        notes = try container.decodeIfPresent("Notes")
        priority = try container.decodeIfPresent("Priority")
        priorityID = try container.decodeIfPresent("PriorityID")
        resolutionNotes = try container.decodeIfPresent("ResolutionNotes")
        resolvedByUser = try container.decodeIfPresent("ResolvedByUser")
        resolvedByUserID = try container.decodeIfPresent("ResolvedByUserID")
        sortOrder = try container.decodeIfPresent("SortOrder")
        status = try container.decodeIfPresent("Status")
        statusID = try container.decodeIfPresent("StatusID")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(assignedToRole, forKey: "AssignedToRole")
        try container.encodeIfPresent(assignedToRoleID, forKey: "AssignedToRoleID")
        try container.encodeIfPresent(assignedToUser, forKey: "AssignedToUser")
        try container.encodeIfPresent(assignedToUserGroup, forKey: "AssignedToUserGroup")
        try container.encodeIfPresent(assignedToUserGroupID, forKey: "AssignedToUserGroupID")
        try container.encodeIfPresent(assignedToUserID, forKey: "AssignedToUserID")
        try container.encodeIfPresent(canConfirm, forKey: "CanConfirm")
        try container.encodeIfPresent(canInvalidate, forKey: "CanInvalidate")
        try container.encodeIfPresent(canReopen, forKey: "CanReopen")
        try container.encodeIfPresent(canResolve, forKey: "CanResolve")
        try container.encodeIfPresent(company, forKey: "Company")
        try container.encodeIfPresent(companyID, forKey: "CompanyID")
        try container.encodeIfPresent(confirmedByUser, forKey: "ConfirmedByUser")
        try container.encodeIfPresent(confirmedByUserID, forKey: "ConfirmedByUserID")
        try container.encodeIfPresent(dateConfirmed, forKey: "DateConfirmed")
        try container.encodeIfPresent(dateDue, forKey: "DateDue")
        try container.encodeIfPresent(dateInvalidated, forKey: "DateInvalidated")
        try container.encodeIfPresent(dateResolved, forKey: "DateResolved")
        try container.encodeIfPresent(delayCode, forKey: "DelayCode")
        try container.encodeIfPresent(description, forKey: "Description")
        try container.encodeIfPresent(entityID, forKey: "EntityID")
        try container.encodeIfPresent(forecastDate, forKey: "ForecastDate")
        try container.encodeIfPresent(hoursLost, forKey: "HoursLost")
        try container.encodeIfPresent(id, forKey: "ID")
        try container.encodeIfPresent(invalidatedByUser, forKey: "InvalidatedByUser")
        try container.encodeIfPresent(invalidatedByUserID, forKey: "InvalidatedByUserID")
        try container.encodeIfPresent(isEditable, forKey: "IsEditable")
        try container.encodeIfPresent(isUrgent, forKey: "IsUrgent")
        try container.encodeIfPresent(name, forKey: "Name")
        try container.encodeIfPresent(notes, forKey: "Notes")
        try container.encodeIfPresent(priority, forKey: "Priority")
        try container.encodeIfPresent(priorityID, forKey: "PriorityID")
        try container.encodeIfPresent(resolutionNotes, forKey: "ResolutionNotes")
        try container.encodeIfPresent(resolvedByUser, forKey: "ResolvedByUser")
        try container.encodeIfPresent(resolvedByUserID, forKey: "ResolvedByUserID")
        try container.encodeIfPresent(sortOrder, forKey: "SortOrder")
        try container.encodeIfPresent(status, forKey: "Status")
        try container.encodeIfPresent(statusID, forKey: "StatusID")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? O3APIDelayDTO else { return false }
      guard self.assignedToRole == object.assignedToRole else { return false }
      guard self.assignedToRoleID == object.assignedToRoleID else { return false }
      guard self.assignedToUser == object.assignedToUser else { return false }
      guard self.assignedToUserGroup == object.assignedToUserGroup else { return false }
      guard self.assignedToUserGroupID == object.assignedToUserGroupID else { return false }
      guard self.assignedToUserID == object.assignedToUserID else { return false }
      guard self.canConfirm == object.canConfirm else { return false }
      guard self.canInvalidate == object.canInvalidate else { return false }
      guard self.canReopen == object.canReopen else { return false }
      guard self.canResolve == object.canResolve else { return false }
      guard self.company == object.company else { return false }
      guard self.companyID == object.companyID else { return false }
      guard self.confirmedByUser == object.confirmedByUser else { return false }
      guard self.confirmedByUserID == object.confirmedByUserID else { return false }
      guard self.dateConfirmed == object.dateConfirmed else { return false }
      guard self.dateDue == object.dateDue else { return false }
      guard self.dateInvalidated == object.dateInvalidated else { return false }
      guard self.dateResolved == object.dateResolved else { return false }
      guard self.delayCode == object.delayCode else { return false }
      guard self.description == object.description else { return false }
      guard self.entityID == object.entityID else { return false }
      guard self.forecastDate == object.forecastDate else { return false }
      guard self.hoursLost == object.hoursLost else { return false }
      guard self.id == object.id else { return false }
      guard self.invalidatedByUser == object.invalidatedByUser else { return false }
      guard self.invalidatedByUserID == object.invalidatedByUserID else { return false }
      guard self.isEditable == object.isEditable else { return false }
      guard self.isUrgent == object.isUrgent else { return false }
      guard self.name == object.name else { return false }
      guard self.notes == object.notes else { return false }
      guard self.priority == object.priority else { return false }
      guard self.priorityID == object.priorityID else { return false }
      guard self.resolutionNotes == object.resolutionNotes else { return false }
      guard self.resolvedByUser == object.resolvedByUser else { return false }
      guard self.resolvedByUserID == object.resolvedByUserID else { return false }
      guard self.sortOrder == object.sortOrder else { return false }
      guard self.status == object.status else { return false }
      guard self.statusID == object.statusID else { return false }
      return true
    }

    public static func == (lhs: O3APIDelayDTO, rhs: O3APIDelayDTO) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
